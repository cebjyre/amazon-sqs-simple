#!/usr/bin/perl -w

use Amazon::SQS::Simple;
use File::Basename;
use Getopt::Long;
use Time::HiRes qw(time);

use constant DEFAULT_VISIBILITY_TIMEOUT => 30*60;

use strict;

my $duration        = 120; # test duration in seconds
my $kids            = 3;
my $padding_length  = 60000;
my $help            = 0;
my $scr             = basename($0);
my $logfile         = "/var/tmp/$scr.log";
my $AWSAccessKeyId  = '0QJGP26J6TDAM7FF06G2'; # rtip-scrum@amazon.com
my $SecretKey       = '3a5P6Sz4LDqUlidEHBdebpBPWx9Ck//Cifh6Bsnc';
my ($q, $msg, @kids);

GetOptions(
    'duration=i'        => \$duration,
    'kids=i'            => \$kids,
    'padding-length=i'  => \$padding_length,
    'help'              => \$help,
    'logfile=s'         => \$logfile,
);
die "kids must be positive integer" unless $kids =~ /^\d+$/ && $kids > 0;

if ($help || @ARGV) {
    print "Usage: $scr [--duration=SECS] [--kids=N] [--padding-length=BYTES] [--logfile=FILE] [--help]\n";
    exit(!$help);
}

my $sqs = new Amazon::SQS::Simple($AWSAccessKeyId, $SecretKey);
my $queues = $sqs->ListQueues();

if ($queues) {
    $q = $queues->[0];
}
else {
    $q = $sqs->CreateQueue('prio_1');
}

open(LOG, ">>$logfile") or die "On opening $logfile for appending: $!";

printlog("Using queue: $q");
printlog("Using padding length: $padding_length bytes");

# set low timeout while resetting
$q->SetAttribute('VisibilityTimeout', 1);
my $att = $q->GetAttributes();

if ($att->{ApproximateNumberOfMessages}) {
    printlog("Approx. " . $att->{ApproximateNumberOfMessages} . " messages in queue - resetting");

    while(defined(my $msg = $q->ReceiveMessage())) {
        my ($ppid, $id) = split(/:/, $msg->{MessageBody});
        printlog("Deleting message $id");
        $q->DeleteMessage($msg->{MessageId});
    }
}

$q->SetAttribute('VisibilityTimeout', +DEFAULT_VISIBILITY_TIMEOUT);

my $attrs = $q->GetAttributes();
for (keys %$attrs) {
    print "Queue attribute: $_ => $attrs->{$_}\n";
}

printlog("Running test for ${duration}s");
my $t_start = time;

printlog("Forking kids");

for (1 .. $kids) { 
    push @kids, make_new_child();
}

# PRODUCER
my $i = 0;

LOOP: while(1) {
    my $t_send = time;
    last LOOP if $t_send - $t_start >= $duration;

    $i++;
    printlog("Sending $i");

    $msg = sprintf("$$:%i:%0.3f:%s", $i, $t_send, ('0' x $padding_length));

    eval {
        $q->SendMessage($msg);
    };
    printlog($@, {level => 'ERROR'}) if $@;
    sleep(2);
}

my $sleep = 30;
printlog("Producer is done, last message sent was $i");
printlog("Sleeping $sleep seconds while kids clean up");
sleep($sleep);
printlog("Killing kids");

kill 'INT' => @kids;
close LOG;
exit;

sub make_new_child {
    my $pid = fork();

    die "Tried to fork, it didn't work: $!" unless defined($pid);

    if ($pid) {
        return $pid;
    }
    else {
        # CONSUMER

        printlog("Started new child process: $$");
     
        LOOP: while (1) {

            my $t_request = time;

            eval {
                $msg = $q->ReceiveMessage();
            };
            if ($@) {
                printlog($@, {level => 'ERROR'}) if $@;
                next LOOP;
            }
            my $t_receive = time;

            if (defined $msg) { 
                my ($ppid, $id, $t_send) = split (/:/, $msg->{MessageBody});

                printlog(sprintf("%i\t%i\t%0.3f\t%0.3f", $id, $ppid, $t_receive - $t_request, $t_receive - $t_send));

                eval {
                    $q->DeleteMessage($msg->{MessageId});
                };
                printlog($@, {level => 'ERROR'}) if $@;
            }
            else {
                # Nothing to receive, sleep for a bit
                sleep(1);
            }
        }
        exit;
    }
}

sub printlog {
    my ($msg, $opts) = @_;
    chomp($msg);

    my $level = $opts->{level} || 'INFO';

    my $logline = sprintf("%s %i\@$scr [%s] %s\n", scalar(gmtime), $$, $level, $msg);
    syswrite LOG, $logline;
    if (-t STDIN) {
        syswrite STDOUT, $logline;
    }
}

