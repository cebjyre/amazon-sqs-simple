#!/usr/bin/perl -w

use Amazon::SQS::Simple;
use File::Basename;
use Getopt::Long;
use Time::HiRes qw(time);

use strict;

my $duration       = 120; # test duration in seconds
my $kids           = 3;
my $padding_length = 60000;

GetOptions(
    'duration=i'       => \$duration,
    'kids=i'           => \$kids,
    'padding-length=i' => \$padding_length,
);
die "kids must be positive integer" unless $kids =~ /^\d+$/ && $kids > 0;

my $scr             = basename($0);
my $AWSAccessKeyId  = '0QJGP26J6TDAM7FF06G2'; # rtip-scrum@amazon.com
my $SecretKey       = '3a5P6Sz4LDqUlidEHBdebpBPWx9Ck//Cifh6Bsnc';
my ($q, $msg, @kids);

my $sqs = new Amazon::SQS::Simple( 
    AWSAccessKeyId  => $AWSAccessKeyId, 
    SecretKey       => $SecretKey,
);

my $queues = $sqs->ListQueues();

if ($queues) {
    $q = $queues->[0];
}
else {
    $q = $sqs->CreateQueue('prio_2');
}

printlog("Using queue: $q");
printlog("Using padding length: $padding_length bytes");

# set no timeout while resetting
$q->SetAttribute('VisibilityTimeout', 0);
my $att = $q->GetAttributes();

if ($att->{ApproximateNumberOfMessages}) {
    printlog("Approx. " . $att->{ApproximateNumberOfMessages} . " messages in queue - resetting");

    while(defined(my $msg = $q->ReceiveMessage())) {
        my ($id) = split(/:/, $msg->{MessageBody});
        printlog("Deleting message $id");
        $q->DeleteMessage($msg->{MessageId});
    }
}

# 30 minute timeout
$q->SetAttribute('VisibilityTimeout', 30*60);

printlog("Running test for ${duration}s");
my $t_start = time;

printlog("Forking kids");

for (1 .. $kids) { 
    push @kids, make_new_child();
}

# PRODUCER
my $i = 0;

LOOP: while(1) {
    my $t_send = time;
    last LOOP if $t_send - $t_start >= $duration;

    $i++;
    printlog("Sending $i");

    $msg = sprintf("$$:%i:%0.3f:%s", $i, $t_send, ('0' x $padding_length));

    eval {
        $q->SendMessage($msg);
    };
    printlog($@, {level => 'ERROR'}) if $@;
}

my $sleep = 30;
printlog("Producer is done, last message sent was $i");
printlog("Sleeping $sleep seconds while kids clean up");
sleep($sleep);
printlog("Killing kids");

kill 'INT' => @kids;

exit;

sub make_new_child {
    my $pid = fork();

    die "Tried to fork, it didn't work: $!" unless defined($pid);

    if ($pid) {
        return $pid;
    }
    else {
        # CONSUMER

        printlog("Started new child process: $$");
     
        LOOP: while (1) {

            my $t_request = time;

            eval {
                $msg = $q->ReceiveMessage();
            };
            if ($@) {
                printlog($@, {level => 'ERROR'}) if $@;
                next LOOP;
            }
            my $t_receive = time;

            if (defined $msg) { 
                my ($ppid, $id, $t_send) = split (/:/, $msg->{MessageBody});

                printlog(sprintf("%i\t%i\t%0.3f\t%0.3f", $id, $ppid, $t_receive - $t_request, $t_receive - $t_send));

                eval {
                    $q->DeleteMessage($msg->{MessageId});
                };
                printlog($@, {level => 'ERROR'}) if $@;
            }
            else {
                # Nothing to receive, sleep for a bit
                sleep(1);
            }
        }
        exit;
    }
}

sub printlog {
    my ($msg, $opts) = @_;
    chomp($msg);

    my $level = $opts->{level} || 'INFO';

    printf("%s %i\@$scr [%s] %s\n", scalar(gmtime), $$, $level, $msg);
}
